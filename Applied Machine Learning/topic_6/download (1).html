<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="google-site-verification" content="_SXyl5T3hvOdDzBuw4EVGD8qyT4ipkQ-4S0TN41zvdI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Visualizing DBSCAN Clustering</title>

    <!-- Local stylesheets -->
    <link rel="stylesheet" type="text/css" href="/static/css/style.css" />

    <!-- Fonts -->
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif|Oxygen' rel='stylesheet' type='text/css'>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/favicon.ico?1=1" />

</head>
<body>
    <header>
        <div><a href=/><img src="/static/img/logosmall.png" alt="Naftali Harris" height="120" width="318"></a></div>
    </header>
    <nav>
    <ul>
        <li><a href=/blog/>Blog</a></li>
        <li><a href=/>About</a></li>
        <li><a href=/contact/>Contact</a></li>
        <li><a href=/random/>I'm Feeling Lucky</a></li>
    </ul>
    </nav>
<div class="content">
  <h1 id="visualizing-dbscan-clustering"><a href="/blog/visualizing-dbscan-clustering">Visualizing DBSCAN Clustering</a></h1>
  <p class="postdate">January 24, 2015</p>
  
<p>
A previous post covered clustering with the <a href="/blog/visualizing-k-means-clustering">k-means algorithm</a>. In this post, we consider a fundamentally different, density-based approach called DBSCAN. In contrast to k-means, which modeled clusters as sets of points near to their center, density-based approaches like DBSCAN model clusters as high-density clumps of points. To begin, choose a data set below:
</p>

<style>
  input {
    font-size: 40px;
  }

  text.choice_text {
    font-size: 20px;
  }

  text.choice_title {
    font-size: 40px;
  }
</style>

<script src="/static/js/d3.v3.min.js"></script>
<script src="/blog/cluster-lib/choose.js"></script>
<script src="/blog/cluster-lib/generate.js"></script>
<script src="/blog/cluster-lib/config.js"></script>
<script src="./dbscan.js"></script>
<script src="./main.js"></script>
<div id="svg_area" style="margin-top: 40px;"></div>
<div id="button_area" style="margin-top: 10px;"></div>
<script>restart();</script>

<br>
<p>
<a href="http://en.wikipedia.org/wiki/DBSCAN">DBSCAN</a>, (Density-Based Spatial Clustering of Applications with Noise), captures the insight that clusters are dense groups of points. The idea is that if a particular point belongs to a cluster, it should be near to lots of other points in that cluster.
</p>
<p>
It works like this: First we choose two parameters, a positive number epsilon and a natural number minPoints. We then begin by picking an arbitrary point in our dataset. If there are more than minPoints points within a distance of epsilon from that point, (including the original point itself), we consider all of them to be part of a &quot;cluster&quot;. We then expand that cluster by checking all of the new points and seeing if they too have more than minPoints points within a distance of epsilon, growing the cluster recursively if so.
</p>
<p>
Eventually, we run out of points to add to the cluster. We then pick a new arbitrary point and repeat the process. Now, it's entirely possible that a point we pick has fewer than minPoints points in its epsilon ball, and is also not a part of any other cluster. If that is the case, it's considered a &quot;noise point&quot; not belonging to any cluster.
</p>
<p>
(There's a slight complication worth pointing out: say minPoints=4, and you have a point with three points in its epsilon ball, including itself. Say the other two points belong to two different clusters, and each has 4 points in their epsilon balls. Then both of these dense points will &quot;fight over&quot; the original point, and it's arbitrary which of the two clusters it ends up in. To see what I mean, try out &quot;Example A&quot; with minPoints=4, epsilon=1.98. Since DBSCAN considers the points in an arbitrary order, the middle point can end up in either the left or the right cluster on different runs. This kind of point is known as a &quot;border point&quot;).
</p>
<p>
To illustrate the &quot;epsilon ball rules&quot;, before the algorithm runs I superimpose a grid of epsilon balls over the dataset you choose, and color them in if they contain more than minPoints points. To get an additional feel for how this algorithm works, check out the &quot;DBSCAN Rings&quot; dataset, which consists of different numbers of points in different sized circles.
</p>
<p>
Note that in the actual DBSCAN algorithm, epsilon and minPoints remain the same throughout. But I thought it'd be fun to play around with changing them while the algorithm is running, so I've left the option in to do so.
</p>
<p>
Take a look at how the <a href="/blog/visualizing-k-means-clustering">k-means algorithm</a> performs on these same datasets. How does it compare? Where is it better and where is it worse?
</p>


  <div id="social-row">
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="https://www.naftaliharris.com/blog/visualizing-dbscan-clustering" data-via="naftaliharris" data-lang="en" data-dnt="true">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    <a href="/rss.xml"><img src="/static/img/rss_inline.png"></a>
  </div>

  <h3>You might also enjoy...</h3>
  <ul class="blogpicks">
    <li><a href="/blog/visualizing-k-means-clustering/">Visualizing K-Means Clustering</a></li>
    <li><a href="/blog/lasso-polytope-geometry/">Visualizing Lasso Polytope Geometry</a></li>
    <li><a href="/blog/steinviz/">Visualizing the James-Stein Estimator</a></li>
  </ul>

</div>

<footer><div>&copy; Naftali Harris, 2012-2023</div></footer>

<!-- Local javascript first -->

<!-- Remote javascript next -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37456569-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>